public class ThreadSample01 {

    /**
     * ===============================
     * üîπ THREADS & MULTITHREADING IN JAVA
     * ===============================
     */

    /*
     * ‚úÖ What is a Thread?
     * A thread is a **lightweight unit of execution** within a process.
     * It represents a single sequential flow of control within a program.
     *
     * ‚úÖ Multitasking vs Multithreading
     * - Multitasking: Running multiple **processes** simultaneously (e.g., listening to music while coding).
     * - Multithreading: Running multiple **threads** within a single process (e.g., background tasks in an app).
     */

    /*
     * ‚úÖ What is a Process?
     * A process is an instance of a running program.
     * Each process runs in its own memory space and can have one or more threads.
     */

    /**
     * ==========================================
     * üîπ THREAD INTERNALS - What happens under the hood?
     * ==========================================
     *
     * - When a Java program is run, the JVM starts with the **main thread**.
     * - Additional threads can be created by the developer or libraries.
     * - Each thread is backed by a **native kernel thread**, created by the OS.
     *
     * Internally, each thread has:
     * - **Program Counter (PC)**: Points to the next instruction to execute.
     * - **Registers**: Hold temporary data for CPU computation.
     * - **Stack**: Stores method calls, local variables, and arguments.
     *
     * üîÅ When context-switching happens:
     * - The OS stores the thread's PC, stack, and registers in a **Thread Control Block (TCB)**.
     * - When the thread resumes, this state is restored to continue exactly where it left off.
     */

    /**
     * ‚úÖ Memory Layout:
     *
     * STACK:
     * - Thread-specific memory region
     * - Stores local variables, method call frames, arguments
     *
     * HEAP:
     * - Shared among all threads
     * - Stores objects, static variables, instance members
     *
     * Example:
     *     void main() {
     *         int x = 1;
     *         int y = 2;
     *         int result = x + y;
     *     }
     * - All above variables reside on the stack
     */

    /**
     * ====================================
     * üîπ Creating Threads in Java
     * ====================================
     *
     * ‚úÖ Two primary ways:
     *
     * 1. **Extend Thread class**
     *     class MyThread extends Thread {
     *         public void run() {
     *             // Task logic here
     *         }
     *     }
     *
     * 2. **Implement Runnable interface**
     *     class MyRunnable implements Runnable {
     *         public void run() {
     *             // Task logic here
     *         }
     *     }
     *
     * - Use `new Thread(new MyRunnable()).start()` to start the thread.
     * - Prefer `Runnable` for better flexibility (can extend other classes).
     */

    /**
     * ‚úÖ Modern Approach ‚Äì Executor Framework
     *
     * - Better alternative to manually creating threads.
     * - Provides thread pooling, task scheduling, and lifecycle management.
     *
     * Key Components:
     * - `ExecutorService` ‚Äì manages thread pools
     * - `Future<V>` ‚Äì represents result of asynchronous computation
     * - `Callable<V>` ‚Äì like Runnable, but returns a value and can throw exceptions
     * - `CompletableFuture` ‚Äì modern async programming with chaining and callbacks
     */

    /**
     * ===========================
     * üîπ When to Use Threads?
     * ===========================
     *
     * - ‚úÖ I/O-bound tasks: reading/writing files, making API calls (non-blocking improves performance)
     * - ‚úÖ CPU-bound tasks: heavy computation that can be split across cores
     * - ‚úÖ GUI applications: offload long tasks to avoid freezing the UI (e.g., Swing, JavaFX)
     * - ‚úÖ Server-side apps: handle multiple client requests concurrently (e.g., web servers)
     */

    /*
     * üí° Pro Tip for Interviews:
     * - Understand **thread lifecycle** (NEW ‚Üí RUNNABLE ‚Üí RUNNING ‚Üí BLOCKED/WAITING ‚Üí TERMINATED)
     * - Know about **synchronization, deadlocks, race conditions, wait/notify**
     * - Be familiar with high-level concurrency tools from `java.util.concurrent`
     * - Practice using Executors and CompletableFutures for async programming
     */
}
