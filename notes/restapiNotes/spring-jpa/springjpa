spring.jpa.hibernate.ddl-auto=create-drop
https://www.baeldung.com/spring-data-derived-queries
https://www.baeldung.com/spring-data-jpa-query
https://www.baeldung.com/spring-data-jpa-stored-procedures
https://www.baeldung.com/hibernate-identifiers
https://www.baeldung.com/hibernate-identifiers


JPA Java persistence api and is a standard from oracle to perform object relational mapping in java ee applications
It has a specification and api -- specification is for orm providers like hibernate and openjpa
api is for us developers to understand and learn we now need to just understand these api and the vendors
will impleent the jpa specification.
we will master jpa api and these providers like hibernate will implemnt them ,,
so tomorrow we can change the provider without chage in code

In the context of databases and ORM (Object-Relational Mapping) frameworks like Hibernate,
a dialect refers to a specific implementation or variant of a particular database management system (DBMS).
It provides the necessary functionality and syntax specific to that DBMS to interact with the database.

Each DBMS may have its own SQL syntax, data types, and features that are unique to that system.
For example, PostgreSQL has its own set of SQL commands and data types, which may differ from those of MySQL or Oracle.

A dialect acts as an intermediary between the ORM framework and the underlying database.
It translates the ORM framework's generic SQL queries and commands into the specific SQL syntax understood by the target DBMS.

By configuring the appropriate dialect for your DBMS, the ORM framework can generate the correct SQL statements and leverage the specific features and optimizations provided by the database.

For example, when using Hibernate with Spring Boot and PostgreSQL, you would typically specify the PostgreSQL dialect in your configuration to ensure that Hibernate generates the correct SQL statements and takes advantage of PostgreSQL-specific features.

Spring data jpa removes all the boiler plate code -- no need for data access layers like dao daoimpl or jdbc queriees
just create our entity and in application yml file we need to map the

GenerationType.IDENTITY: This strategy indicates that the primary key value will be generated by the database automatically upon insertion.
It typically relies on an auto-increment column in the database. This strategy is commonly used with databases like MySQL and PostgreSQL.

GenerationType.SEQUENCE:
This strategy indicates that the primary key value will be generated using a database sequence.
A sequence is a database object that generates unique values for each request. This strategy is commonly used with databases like Oracle.

GenerationType.TABLE: This strategy indicates that the primary key value will be generated using a separate table to maintain the sequence of generated values.
The table contains a row for each entity type and column to store the last generated value for that entity. This strategy is more portable across different database systems.

GenerationType.AUTO: This strategy allows the persistence provider (e.g., Hibernate) to choose the most appropriate strategy based on the underlying database and its capabilities

By using @GeneratedValue with one of these strategies, you can let the JPA provider handle the generation of primary key values for your entity.

SpringData Jpa--
@Entity -- @Table  @Column  @Transactional
https://www.baeldung.com/spring-transactional-propagation-isolation

Propagation level are Required Requires_New,Supports,Mandatory,Nested,Never,Not_Supported
@Transactional(propagation=Propagation.Required)
Required-- same transaction is used -- if not spring container creates a new transaction
            inner methods have distinct logical transaction but same physical transaction .
            if inner method fails outer method will also fail to commit.
            unchedcked exceptions cause state to rollback if we want checked to also casue
            we need to set them
            eg @Transactional(propagation=Propagation.Required,rollbackfor=SOmeCheckedException)

Requires_New -- both inner and outer have different physical transactions and will be independent of each other
                so if inner has an exception it will rollback but not outer
                the inner method always creates a new transaction

Nested - This only used with SpringJdbc managed transactions .
        same physical transaction inner and outer but has savepoints so inner transaction may rollback independently of USERSGROUPS_SYSTEM_USER_ID

Not_Supported-  it will exceute outside the scope of a transaction even if the calling method has a transaction.
Never -- means if a method is annotated with this annotation it should nerver run inside a transaction,if it is being called from a method
         that has a transaction it will  thrw an error.. and it it doesn not have it will run without a transaction
Mandatory -- on a method or class should always run in a transaction-- if inner method is called directly it throws an excetption
            it uses the transaction of the caller and if it does not have throws an error
Supports- it will nt create a new  transaction , but if it is called from a method which uses transaction it will use its transaction but will never create a
           a new transaction on it own.

Isolation Levels
Dirty Reads -- Transaction A  -- updates a data before it commits transaction b reads it --
Non-Repeatabale read -- Transaction A -- queries a database
                        Transaction B -- updates
                        Transaction A -- agains queries
Phantom Reads ------- Transaction A --- queries
                      transaction B  -- inserts
                      Transaction A -- again reads gets different data


In java e differentIsolation levels are
Read Uncommitted -- all three hapen -- dirty read ,non Repeatabale and phantom
Read Comitted -- avoids dirty Reads
Repeatable read -- phantom reads still happen
Serializable -- all three avoided but --performace takesa hit


Optimistic vs Pessimistic locking
these are different ways in which transactions read data

Optimistic -- there is no locking of data -- it reads and updates the version/timestamp
            another transaction will check what is the version/timestamp and see it is the sanme or not
            if not it will redo and update,
            used for apps with hgh reads and less updates

Pessimistic - we lock the database -- set different Isolation levels
