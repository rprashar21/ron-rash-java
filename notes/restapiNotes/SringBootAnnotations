Spring annotations
marks the entry point of a Spring Boot application.when ur spring boot application
runs Spring Boot auto-configures your environment based on dependencies on the classpath,
scans your packages for @Component, @Service, @Repository, etc., and initializes everything.
@SpringBootApplication -- combination of  @enableAutoconfiguration,@componetScan,`@configuration

enableAutoconfiguration-  auto configures the spring application and all the dependencies we have in the classpath and creates
beans for that -- looks in the pom.xml -- for eg if we have h2 database jar it will configure all the beans related totto that

ComponentScan -- it will scan the beans and will make it visible to all the Ioc conatiner
we can also provide the base packages and classes to load specific classes to the ioc container

@Configuration -- used for java based configuration -- we have bean definitions inside this class and when a componentScan
is scan all the beans and provide it to the ioc conatiner..

Sterotype Annotations? -- spring will see these annotaions and manage the lifecycle of these beans
@Component - generic to mark a class to be manged by the spring comatiner , o additional behaviour
@Service -annotaion for the service layer , used for business logic
@Repository - indicates dao layer , componets interacting with datbase , converts db exception to springs dataaccess exceptions
@RestController - web conteroller to handle web request

@PostConstruct -- when the spring context has finished creating the beans -- ie Sterotype annotations-(we have no control over)
and we want to execute some instructions we can use this annotation
Like connecting to the db or initializing some data.

@PreDestroy-- Just before destroying all the beans by spring ,this method will be called - eg closing db operations

Spring Core related annotaion
@Configuration and @Bean-- to manage the java based beans/configuration--
we dont want to manage the lifecycle of these beans uig xml or annotations
it is made availabe to the ioc container when it sees it will create the bean and maintain the lifecylce for it --
 usually when we use kafka or restTemplate

What is @Configuration?
Marks a class as a source of bean definitions for the Spring IoC container.
Replaces applicationContext.xml or beans.xml for Java-based configuration.
when we wnat more explicit contorl over bean instantiation
@Configuration
public class AppConfig {
    @Bean // this indicates that this is a bean managed by spring
    public RestTemplate restTemplate() {.  //When Spring scans this class, it will create a singleton bean of type RestTemplate and manage its lifecycle.
        return new RestTemplate();
    }
You can configure external libraries or infrastructure beans here (like Kafka clients, DataSources, etc.).
}


There are 2 types of IOc containers .
1. BeanFactory - Lazy initialization: beans are created only when requested , basic functionality used behind the scenes
2. ApplicationContext - superset of beanfactory -- eager bean loading ,INternationalization ,aop

@Component is for your own classesâ€”Spring will auto-detect and instantiate.
@Bean is for third-party classes or complex initialization logic not under your control.

@Qualifier -- tells ioc or application context / spring which bean to load when there are multiple implementations of a service
this is an example of Qualifier annotation

interface Engine{
  void start();
}

@Component('gasEngine')
class GasEngine implemnts Engine{

  public void start()
  {
   sout("gas engine starting ")
   }
}
@Component('electricEngine')
class ElectricEngine implemnts Engine{

  public void start()
  {
   sout("electric engine  starting ")
   }
}

@Component
public class Car {
    private final Engine engine;

    @Autowired
    public Car(@Qualifier("electricEngine") Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.start();
        System.out.println("Car is running with electric engine.");
    }
}
In this example, when Spring creates the Car bean, it knows that it needs an Engine bean.
There are two Engine beans available (ElectricEngine and GasEngine).
By using @Qualifier("electricEngine"), we are instructing Spring to inject the ElectricEngine bean, not the GasEngine bean.

@Primary -- annotate the bean which u want to give priority and annotate It with this

@Component
@Primary
public class PrimaryDatabaseConnection implements DatabaseConnection {
    // ...
}

@Component
public class SecondaryDatabaseConnection implements DatabaseConnection {
    // ...
}

@Service
public class DataService {
    @Autowired
    private DatabaseConnection connection; // Autowires PrimaryDatabaseConnection implementation must be used
    // ...
}


@Lazy -- lazing loading of the Beans
@Value -- to load any value from the properties file @Value("${mail.from}")
@PropertySource


@Profile -- load configuration specific to an environment.

@Configuration
public class config{

@Bean
@Profile("stg")  -- filename should be application-stg.properties
public String dataSourceProps()
{

}
}

@Scope - by default singleton --
prototye -- for every rest call
session -- bean for every ession
request

@RequestBody -- for post when we pass the entire payload and map to our model
@PathVariable-- we have to pass the var in the url else we will get 404 USERSGROUPS_SYSTEM_USER_ID

@GetMapping("/{id}")
@SneakyThrows
public ResponseEntity<Optional<Student>> getStudent(@PathVariable int id )
{

}

@RequestParam -- we can pass   --- url http://localhost:8080/students/bySirName?id=100
@getMapping("/bySirName")
public ResponseEntity<Optional<Student>> getStudent(@RequestParam("id") int id )
{

}

@ControllerAdvice 0r RestControllerAdvice--
When we get an exception spring will look for the above annotations to handle the exceptions-- inside this class we will
look for the exception and

@RestControllerAdvice
public class  ApplicationException{

@ExceptionHandler(StudentException.class)
public ResponseEntity<Error> handleException(Srt ex)
{

}
}

what are dto objects
data transfer object bewtween different layers fo the application --controller ---> service --> repository

Bascailly u can only show what fields u needs -- dont need to expose al the fields

| Benefit                           | Explanation                                                                         |
| --------------------------------- | ----------------------------------------------------------------------------------- |
| ðŸ”„ **Decouples layers**           | UI doesnâ€™t depend on internal entity/model structure.                               |
| ðŸ”’ **Security**                   | You can expose only the needed fields, hiding sensitive data (e.g., password, SSN). |
| ðŸ“¦ **Efficient Network Payloads** | Send only necessary data instead of full objects, reducing size.                    |
| ðŸ”„ **Serialization**              | Easily serialized to JSON/XML when transferring over REST APIs.                     |


@Entity
public class User {
    @Id private Long id;
    private String name;
    private String email;
    private String password; // ðŸ”’ Sensitive
}

public class UserDTO {
    private String name;
    private String email;

    public UserDTO(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Getters and setters
}

public UserDTO getUser(Long id) {
    User user = userRepository.findById(id).orElseThrow();
    return new UserDTO(user.getName(), user.getEmail()); // no password -- no need to send the password
}


What is a record in Java? -- bascailly replaces dto objects
record is a concise way to create immutable DTO-like classes.

public record(Sring name,String status){
// since this isimmutable
// automatically creates constructor ,, getters no setters equals and hascode
// all the fields are final by default

// when to use --w hen u need immutable dtos
// for value object like money or coordinates
In controller response payload
For Kafka message schema
For cache representation
}

// Java record for concise, immutable, serializable DTO
public record OrderSummaryDTO(String orderId, double totalAmount, String status) {}

Jackson supports records for JSON (de)serialization out of the box since Spring Boot 2.6+ (with Java 16+). Just annotate lik
@GetMapping("/order/{id}")
public OrderSummaryDTO getOrder(@PathVariable String id) {
    return new OrderSummaryDTO(id, 599.99, "SHIPPED"); // automatcailly maps to json
}


