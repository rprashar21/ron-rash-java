Imagine a pizza ordering systme
Customer --> orders pizza --> Process Payment -> Make Pizza -> Deliver Pizza
Everything here happens synchronously each step must wait for it to complete

=====================================================================================================================
In our application
Traditional Approach:
User -> Create Hearing -> Update Database -> Notify Parties -> Update Calendar
(Everything happens synchronously, one after another)

Event-Driven Approach:
User creates hearing -> "HearingCreated" event
↓
Database Service (subscribes to "HearingCreated")
↓
"HearingStored" event
↓
Notification Service (subscribes to "HearingStored")
↓
"PartiesNotified" event
↓
Calendar Service (subscribes to "PartiesNotified")

======================================================================================================================
Implementation in the project
The project implements Event-Driven Architecture through several key components:

The event driven architecture is good for comlpex workflows

@ServiceComponent(EVENT_PROCESSOR)
public class ListingEventProcessor {
    @Handles("listing.events.hearing-created")
    public void handleHearingCreated(final JsonEnvelope envelope) {
        // Process the event
        // Emit new events if needed
    }
}

There are 2 types of events emitted
private event
public event

Key components -- different EventHandlers can handle different types of events
Hearing Events - New Hearing Creation , updation sequencing
Case Events  - case linking removal updates

Benefits of this application is
Decoupling: Services don't need to know about each other
Scalability: Each event processor can be scaled independently
Maintainability: Easy to add new event handlers
Reliability: Events can be replayed if processing fails
Audit Trail: All changes are tracked through events

How can we scale the event processors different modules
Each event processor is a separate service component
Multiple instances can be deployed independently
Each instance can handle different types of events

if a particaluar event processor is handling more events , we can scale them
Use container orchestration (like Kubernetes) to automatically scale based on load

Container based scaling
<!-- listing-event-processor/pom.xml -->
<artifactId>listing-event-processor</artifactId>
<packaging>war</packaging>

1. Command API
What it is:
The entry point for clients (UI, other services) to request changes in the system.
Role:Receives commands (requests to perform actions that change state), usually via HTTP endpoints, gRPC, or message queues.
Example:
POST /api/orders { "command": "CreateOrder", ... }

2. Command Handler
What it is:
The component responsible for handling the business logic of a command.
Role:
Validates the command.
Loads the relevant domain aggregate/entity.
Applies the command logic (e.g., changes state, enforces invariants).
Emits domain events as a result of the command.
Example:
CreateOrderCommandHandler processes the CreateOrder command, creates an Order aggregate, and emits an OrderCreated event.

3. Event Source (Event Store)
What it is:
A storage mechanism for all domain events that have occurred.
What it is: A storage mechanism for all domain events that have occurred.
Role:
Persists events generated by command handlers.
Serves as the source of truth for reconstructing aggregate state.
Enables event replay for rebuilding state or projection
Example
Stores events like OrderCreated, OrderShipped, etc.

4.Processor (Event Processor/Projector)
  What it is:
  A component that listens to events and reacts to them, often to update read models or trigger side effects.
  Role:
  Subscribes to the event store or event bus.
  Processes events to update projections (read models) or trigger workflows.
  Example:
  An OrderProjectionProcessor listens for OrderCreated and updates a denormalized orders view.

5. Viewstor (View Store/Read Model Store)
What it is:
A storage optimized for queries, holding the current state as seen by the outside world.
Role:
Stores projections or read models built by processors.
Serves queries efficiently (e.g., via REST API, GraphQL, etc.).
Example:
A database table or cache holding the current list of orders for fast retrieval.