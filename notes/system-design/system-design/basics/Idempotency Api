Idempotency means: calling the same API request multiple times should have the same effect as calling it once.
The server track each request --adds a uniue id to the request -- store it in the cache or db ,, check if its present if yes
duplicate the reponse

if the action is not idempotent it will deduct money twice maybe send 2 emails 2 confiramtiosn

Real world
POST /api/payments
request body
{
  "amount": 250,
  "currency": "GBP",
  "recipientId": "user-456"
}
Add idempotency key header
POST /api/payments
Idempotency-Key: 123e4567-e89b-12d3-a456-426614174000
This key is generated by the client, unique per intent. Think of it as a "receipt number"

retires
| Strategy              | Description                                          |
| --------------------- | ---------------------------------------------------- |
| ✅ Fixed Delay         | Retry every N seconds (simple, but can cause spikes) |
| ✅ Exponential Backoff | Wait 1s, 2s, 4s, 8s... reduces pressure              |
| ✅ Fibonacci           | 1s, 1s, 2s, 3s, 5s... smoother growth                |
| ✅ Jitter              | Add randomness to avoid **thundering herd**          |


cleint -- Always generates a UUID idempotency key, send it in the header

backend code
public ResponseEntity<PaymentResponse> initiatePayment(HttpRequest request) {
    String idempotencyKey = request.getHeader("Idempotency-Key"); / chekc this key against the cache

// Example Java client-side retry with exponential backoff + jitter
int retries = 0;
int delay = 1000; // Start at 1s
Random random = new Random();

while (retries < 5) {
    try {
        Response res = sendPaymentRequestWithIdempotencyKey();
        if (res.isSuccessful()) break;
    } catch (IOException e) {
        Thread.sleep(delay + random.nextInt(250)); // Add jitter
        delay *= 2; // Exponential backoff
        retries++;
    }
}
Server
Checks idempotency key in a store (DB, Redis)
Returns same response if seen before
On success, saves the result with the key
On failure, does not store — so retry can reattemp

Say we have millions of. request -- cache can get overloaded -- set a ttl for the keys ,
eveiction policy -- lru
settting a ttl
redisTemplate.opsForValue().set(idempotencyKey, result, Duration.ofHours(24));

config in redis
maxmemory 2gb
maxmemory-policy allkeys-lru -- eventcion policy

if u need to retain the keys for a longer time u can basically store the keys in a separate db -- run background job to detlete those keys

Protect from Abuse -- rate limiting
If someone floods your API with random idempotency keys, you could blow the cache.
Rate limiting per IP/token/client
Validation of the idempotency key format (UUID only, length limit)
Max usage count per key


Scenario
Store the result in Redis/db before confirming external side-effects (e.g., card charge success).


======Real world problem ===
Every external-facing API that causes a side-effect (money movement, email, invoice, etc.) must be idempotent.