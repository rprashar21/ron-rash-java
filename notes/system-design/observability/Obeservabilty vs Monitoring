Observability is the ability to understand the internal state of the system.

3 main components of observabilty of microservice is
1. Metrics --> quantitatve mesasurements like cpu usage ,memeory usage ,response times
2. Logs -- recording events in the system , see logs ,error eceptions and unexpected events
3. Trace -- tracing a  request response to identofy bottlenck

Monitoring -    collecting telemetry data for the application and creating alerts ,, tracks  the overall health of teh system
1. identify problems in ur system
2. track health and aotimize ur micrsoervec
                                |


Real-World Example in Microservices
Let's say your order processing service is slow.
Monitoring will: Alert you that average response time > 3s. Show you CPU/memory spikes in dashboards.
Tell you what is wrong, not why.

Observability will:
Let you trace a request through the order, payment, and inventory services.
Show logs, timestamps, and failure points in the distributed trace.
Help you identify that inventory service is calling an external API that is timing out.

Im microsevrice since we have many services centralized loggging is best option
grafana is open source for interactive visualization web application

Prometheus and Grafana are open source
Prometheus, for metrics building dashboards as well
Grafana -- for aggreagating the log we can use grafana
Grafana temp for tracing

microservices ----> promtail{fetch logs from services and forwards to loki} ----->
forwards the logs to loki{log integration system} --->Grafna{query,search,visulizethe logs with loki as datasource}
 Prometheus and Grafana are indeed fantastic tools for observability.
 While Azure Monitor is more integrated with Azure services,
 Prometheus offers powerful metric collection capabilities,
 and Grafana excels at creating highly customizable dashboards.
 But let's chat about the foundations of observability—like telemetry data or the RED method—and build from there.
 What’s your take on telemetry data, for instance

 What is the red method
 r- rate --measure thruput or requests handled by our system or application over time (requests per second or queries per min)
          tracks how bsy the system is
 error - tracks failed request , helping us to identiy issues
 duration - Monitors the time taken to process requests latency or response times,
  often broken into percentiles like p50, p95, p99 for average, near-worst, and worst-case scenario

Suppose you're monitoring an e-commerce app's checkout API:

Rate: 100 checkouts per minute during peak hours—if it drops suddenly, it might indicate a upstream service failure.
Errors: 5% of checkouts fail due to payment gateway issues—telemetry logs help debug this.
Duration: Average checkout takes 2 seconds, but p99 is 10 seconds—indicating slow database queries for some users.

By collecting and analyzing these telemetry signals, developers can set slaerts and loot the system


Imagine a popular mobile game app like Candy Crush. When you play, the app might collect telemetry data such as:

How long levels take to load.
Which levels players get stuck on most often (e.g., level 50 has a 70% drop-off rate).
Error logs if the app crashes on certain devices (e.g., "OutOfMemoryError on Android 12").
Anonymous stats like "X% of users prefer power-up Y."

This data is sent to the developers' servers periodically.
They use it to fix bugs (e.g., optimize memory for Android), balance difficulty (e.g., make level 50 easier),
or add popular features, ultimately improving the game for everyone without knowing who you are personally.
 Tools like Google Analytics, Microsoft Application Insights, or open-source options like Prometheus are often used for this.



What is the key difference between Promethues and Grafana
Prometheus focuses on the "backend" of monitoring—collecting and storing data—while Grafana handles the "frontend"—visualizing that data.